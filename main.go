package main

import (
	"fmt"
	"log"
	"strings"
	"unicode"
	"unicode/utf8"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func main() {
	var inputType string
	var outputType string
	var filename string
	var goImportPath string

	protogen.Options{
		ParamFunc: func(name, value string) error {
			switch name {
			case "input":
				inputType = value
				return nil
			case "output":
				outputType = value
				return nil
			case "filename":
				filename = value
				return nil
			case "go_import_path":
				goImportPath = value
				return nil
			}
			return fmt.Errorf("unknown parameter %q", name)
		},
	}.Run(func(gen *protogen.Plugin) error {
		var inMsg *protogen.Message
		var outMsg *protogen.Message
		for _, file := range gen.Files {
			for _, msg := range file.Messages {
				log.Println(msg.Desc.FullName())
				if string(msg.Desc.FullName()) == inputType {
					inMsg = msg
				}
				if string(msg.Desc.FullName()) == outputType {
					outMsg = msg
				}
			}
		}

		outFile := gen.NewGeneratedFile(filename, protogen.GoImportPath(goImportPath))

		outFile.P("// Code generated by protoc-gen-encode. DO NOT EDIT.")
		outFile.P()
		outFile.P("package ", reverseString(strings.Split(reverseString(goImportPath), "/")[0]))

		convertMessage(inMsg, outMsg, outFile)

		return nil
	})
}

func convertMessage(inMsg *protogen.Message, outMsg *protogen.Message, g *protogen.GeneratedFile) {
	inFields := map[string]*protogen.Field{}
	for _, field := range inMsg.Fields {
		inFields[field.GoName] = field
	}

	outFields := map[string]*protogen.Field{}
	for _, field := range outMsg.Fields {
		outFields[field.GoName] = field
	}
	log.Println(inFields)
	log.Println(outFields)

	missingFields := map[string]*protogen.Field{}
	for name, field := range inFields {
		if _, ok := outFields[name]; !ok {
			missingFields[name] = field
		}
	}

	extraFields := map[string]*protogen.Field{}
	for name, field := range outFields {
		if _, ok := inFields[name]; !ok {
			extraFields[name] = field
		}
	}

	commonFields := map[string]*protogen.Field{}
	changedFields := map[string]*protogen.Field{}
	for name, field := range inFields {
		inType, inPtr := fieldGoType(g, field)
		if _, ok := missingFields[name]; ok {
			continue
		}
		outType, outPtr := fieldGoType(g, outFields[name])
		if inType != outType || inPtr != outPtr {
			changedFields[name] = field
			continue
		}

		commonFields[name] = field
	}

	for _, field := range inMsg.Fields {
		if _, ok := changedFields[field.GoName]; ok {
			inFieldType, inPtr := fieldGoType(g, field)
			if inPtr {
				inFieldType = "*" + inFieldType
			}

			outFieldType, outPtr := fieldGoType(g, outFields[field.GoName])
			if outPtr {
				outFieldType = "*" + outFieldType
			}

			g.P("type ", field.GoName, "Encoder[T any]", "func(*", g.QualifiedGoIdent(inMsg.GoIdent), ", ", inFieldType, ", T) (", outFieldType, ", error)")
		}
		if _, ok := missingFields[field.GoName]; ok {
			g.P("type ", field.GoName, "AckMissing struct {}")
		}
	}

	for _, field := range outMsg.Fields {
		if _, ok := extraFields[field.GoName]; !ok {
			continue
		}

		fieldType, pointer := fieldGoType(g, field)
		if pointer {
			fieldType = "*" + fieldType
		}
		g.P("type ", field.GoName, "Encoder[T any]", "func(*", g.QualifiedGoIdent(inMsg.GoIdent), ", T) (", fieldType, ", error)")
	}

	g.P("type ", inMsg.GoIdent.GoName, "To", outMsg.GoIdent.GoName, "Encoder[T any] struct {")

	for _, field := range inMsg.Fields {
		if _, ok := commonFields[field.GoName]; ok {
			fieldType, pointer := fieldGoType(g, field)
			if pointer {
				fieldType = "*" + fieldType
			}
			g.P(field.GoName, " func(*", g.QualifiedGoIdent(inMsg.GoIdent), ", ", fieldType, ", T) (", fieldType, ", error)")
		}
		if _, ok := changedFields[field.GoName]; ok {
			g.P(field.GoName, " ", field.GoName, "Encoder[T]")
		}
	}

	for _, field := range outMsg.Fields {
		if _, ok := extraFields[field.GoName]; !ok {
			continue
		}

		g.P(field.GoName, " ", field.GoName, "Encoder[T]")
	}

	g.P("}")

	g.P("func New", inMsg.GoIdent.GoName, "To", outMsg.GoIdent.GoName, "Encoder[T any](")
	for _, field := range inMsg.Fields {
		if _, ok := changedFields[field.GoName]; ok {
			g.P(field.GoName, "Encoder ", field.GoName, "Encoder[T],")
		}
		if _, ok := missingFields[field.GoName]; ok {
			g.P(field.GoName, "AckMissing ", field.GoName, "AckMissing,")
		}
	}

	for _, field := range outMsg.Fields {
		if _, ok := extraFields[field.GoName]; !ok {
			continue
		}
		g.P(field.GoName, "Encoder ", field.GoName, "Encoder[T],")
	}

	g.P(") *", inMsg.GoIdent.GoName, "To", outMsg.GoIdent.GoName, "Encoder[T] {")

	g.P("return &", inMsg.GoIdent.GoName, "To", outMsg.GoIdent.GoName, "Encoder[T]{")

	for _, field := range inFields {
		if _, ok := commonFields[field.GoName]; ok {
			fieldType, pointer := fieldGoType(g, field)
			if pointer {
				fieldType = "*" + fieldType
			}

			g.P(field.GoName, "Encoder: ", "func(outer *", g.QualifiedGoIdent(inMsg.GoIdent), ", ", "in ", fieldType, ", extra T) (", fieldType, ", error) { return in, nil },")
		}

		if _, ok := changedFields[field.GoName]; ok {
			g.P(field.GoName, "Encoder: ", field.GoName, "Encoder,")
		}
	}

	for _, field := range outMsg.Fields {
		if _, ok := extraFields[field.GoName]; !ok {
			continue
		}

		g.P(field.GoName, "Encoder: ", field.GoName, "Encoder,")
	}

	g.P("}")

	g.P("}")

	g.P("func (e *", inMsg.GoIdent.GoName, "To", outMsg.GoIdent.GoName, "Encoder[T]) Encode(in *", g.QualifiedGoIdent(inMsg.GoIdent), ", extra T) (*", g.QualifiedGoIdent(outMsg.GoIdent), ", error) {")

	for _, field := range inMsg.Fields {
		g.P(lowerFirst(field.GoName), ",  err := e.", field.GoName, "Encoder(in, in.", field.GoName, ", extra)")
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
	}

	for _, field := range outMsg.Fields {
		if _, ok := extraFields[field.GoName]; !ok {
			continue
		}

		g.P(lowerFirst(field.GoName), ", err = e.", field.GoName, "Encoder(in, extra)")
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
	}

	g.P("return &", g.QualifiedGoIdent(outMsg.GoIdent), "{")
	for _, field := range inMsg.Fields {
		g.P(field.GoName, ": ", lowerFirst(field.GoName), ",")
	}
	for _, field := range outMsg.Fields {
		if _, ok := extraFields[field.GoName]; !ok {
			continue
		}
		g.P(field.GoName, ": ", lowerFirst(field.GoName), ",")
	}
	g.P("}, nil")

	g.P("return out, nil")
	g.P("}")
}

func fieldGoType(g *protogen.GeneratedFile, field *protogen.Field) (goType string, pointer bool) {
	if field.Desc.IsWeak() {
		return "struct{}", false
	}

	pointer = field.Desc.HasPresence()
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		goType = "bool"
	case protoreflect.EnumKind:
		goType = g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		goType = "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		goType = "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		goType = "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		goType = "uint64"
	case protoreflect.FloatKind:
		goType = "float32"
	case protoreflect.DoubleKind:
		goType = "float64"
	case protoreflect.StringKind:
		goType = "string"
	case protoreflect.BytesKind:
		goType = "[]byte"
		pointer = false // rely on nullability of slices for presence
	case protoreflect.MessageKind, protoreflect.GroupKind:
		goType = "*" + g.QualifiedGoIdent(field.Message.GoIdent)
		pointer = false // pointer captured as part of the type
	}
	switch {
	case field.Desc.IsList():
		return "[]" + goType, false
	case field.Desc.IsMap():
		keyType, _ := fieldGoType(g, field.Message.Fields[0])
		valType, _ := fieldGoType(g, field.Message.Fields[1])
		return fmt.Sprintf("map[%v]%v", keyType, valType), false
	}
	return goType, pointer
}

func reverseString(s string) string {
	size := len(s)
	buf := make([]byte, size)
	for start := 0; start < size; {
		r, n := utf8.DecodeRuneInString(s[start:])
		start += n
		utf8.EncodeRune(buf[size-start:], r)
	}
	return string(buf)
}

func lowerFirst(s string) string {
	r, size := utf8.DecodeRuneInString(s)
	if r == utf8.RuneError || size < 1 {
		return s
	}
	lc := unicode.ToLower(r)
	if lc == r {
		return s
	}
	return string(lc) + s[size:]
}
